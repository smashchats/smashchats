diff --git a/node_modules/smash-node-lib/dist/src/SMESocketReadWrite.js b/node_modules/smash-node-lib/dist/src/SMESocketReadWrite.js
index ea96b3f..a042189 100644
--- a/node_modules/smash-node-lib/dist/src/SMESocketReadWrite.js
+++ b/node_modules/smash-node-lib/dist/src/SMESocketReadWrite.js
@@ -8,7 +8,7 @@ const solveChallenge = async (data, auth, socket, logger) => {
         const symmetricKey = await CryptoUtils.singleton.deriveKey({
             ...auth.keyAlgorithm,
             public: smePublicKey,
-        }, auth.preKeyPair.privateKey, auth.encryptionAlgorithm, false, ['encrypt', 'decrypt']);
+        }, auth.preKeyPair.privateKey, auth.encryptionAlgorithm, true, ['encrypt', 'decrypt']);
         const unencryptedChallenge = await CryptoUtils.singleton.decrypt({
             ...auth.encryptionAlgorithm,
             iv: ivBuffer,
diff --git a/node_modules/smash-node-lib/dist/src/SignalSession.js b/node_modules/smash-node-lib/dist/src/SignalSession.js
index bafbec3..175e367 100644
--- a/node_modules/smash-node-lib/dist/src/SignalSession.js
+++ b/node_modules/smash-node-lib/dist/src/SignalSession.js
@@ -22,15 +22,15 @@ export class SignalSession {
         try {
             const bundle = new PreKeyBundleProtocol();
             bundle.registrationId = 0; // warning: using fixed value, unsure about usage!
-            bundle.identity.signingKey = await ECPublicKey.create(await CryptoUtils.singleton.importKey(peer.ik));
-            bundle.identity.exchangeKey = await ECPublicKey.create(await CryptoUtils.singleton.importKey(peer.ek));
+            bundle.identity.signingKey = await ECPublicKey.create(await CryptoUtils.singleton.importKey(peer.ik, undefined, true));
+            bundle.identity.exchangeKey = await ECPublicKey.create(await CryptoUtils.singleton.importKey(peer.ek, undefined, true));
             bundle.identity.signature = CryptoUtils.singleton.stringToBuffer(peer.signature);
             bundle.preKeySigned.id = 0; // warning: using fixed value, unsure about usage!
-            bundle.preKeySigned.key = await ECPublicKey.create(await CryptoUtils.singleton.importKey(sme.preKey));
+            bundle.preKeySigned.key = await ECPublicKey.create(await CryptoUtils.singleton.importKey(sme.preKey, undefined, true));
             bundle.preKeySigned.signature =
                 CryptoUtils.singleton.stringToBuffer(sme.signature);
             const protocol = await PreKeyBundleProtocol.importProto(bundle);
-            const cipher = await AsymmetricRatchet.create(identity, protocol);
+            const cipher = await AsymmetricRatchet.create(identity, protocol, { exportableKeys: true });
             const sessionId = await CryptoUtils.singleton.keySha256(cipher.currentRatchetKey.publicKey.key);
             return new SignalSession(sessionId, cipher, peer.ik, logger);
         }
